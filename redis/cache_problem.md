# 缓存问题

### 缓存与数据库数据不一致怎么办

假设使用的主存分离, 读写分离的数据库.

发生的可能性: 

1. 主库更新数据, 主库到从库的同步未完成, 从库读取数据, 未读到最新数据, 而更新了缓存

解决方案: 在从库接收到数据更新操作时, 淘汰掉这条数据的缓存

解决方案: 

 常用cache aside先更新db后删除缓存。会有问题有可能会不一致。一般都要加一个过期时间，然后过期时间就会有雪崩问题的引深。真要解决一般就是分布式锁等。用了缓存就会有不一致。 因为cache aside中，读缓存需要在更新之前，并且更新缓存需要在删除缓存之后写入才可能有数据不一致的问题。 但是因为数据库update更新，锁表等操作。肯定是更缓慢的。所以很低概率会发生

1. 在数据性一致性要求不高时, 忽略掉这个数据的不一致
2. 延时双删策略
   1. 先删除缓存
   2. 再写数据库
   3. 休眠500毫秒
   4. 再次删除缓存
   5. 设置缓存过期时间
3. 异步更新缓存(基于订阅binlog的同步机制)
   1. Redis订阅 mysql binlog消息
   2. 依据消息来进行相关操作

### Redis 缓存穿透

起因: 恶意请求故意大量查询不存在的key, 让请求到达MySQL, 对后端造成很大压力
解决方案: 
对不存在的key也做有有效期的缓存; 
对存在  key 做一个 布隆过滤, 不存在于过滤器中的数据直接返回空;

### Redis 缓存雪崩

起因: 大量的缓存在同一时间段失效, 导致后端压力大.
解决方案: 对缓存的有效时间使用不同的过期时间; 做二级缓存; 



### 缓存热点 key 重建

在缓存失效瞬间, 有大量的线程来重建缓存, 造成后端负载压力大, 甚至可能让应用崩溃

解决方案:

1. 互斥锁

多进程获取到锁的可以更新缓存, 其它线程等待. 由于建立缓存是个幂等操作, 所以可以在一两次获取不到锁时, 可以直接绕过互斥锁

2. 永远不过期

### Redis 分布式锁

> 为什么要分布式锁

为了确保在多个线程中, 多服务器中执行任务时, 能够达到一致性

> Redis 为什么可以做分布式锁

Redis 是单线程的(网络请求模块使用了一个线程, 所以不需要考虑并发性), 即一个线程处理所有网络请求, 其它模块仍用了多个线程.

> 如何用

使用 `setnx key value`即加锁, 其它线程再来设置会返回false
`del key` 释放锁

> 解决死锁

1. Redis控制: 使用 `setnx key value` 后, 立即使用 `expire key timeout` 设置有效期.
2. 其它服务器控制: 通过 `value` 设置为失效时的时间戳(比如当前+1s), 其它服务器在获取锁时发现锁还在, 且超过了有效期, 就直接来释放锁, 在释放锁这个过程, 需要使用 `GETSET key value` 来操作, 直接对这个key进行`getset`, 看返回值如果是过期的, 说明拿到了锁, 反之拿失败了. 拿失败的情况下, 需要放弃后续的操作了

> 缺陷

当master上加了锁, 还未同步到 slave 时, master down了, 这个时候 slave 成为了 master, 其中并没有锁, 这个时候就会出现多个客户端同时拿到锁的问题.

> 锁延期机制 (watch dog)

当客户端超过了key的生存时间还在操作, 想要继续有这个锁, 那么可以使用看门狗程序, 在生存时间内会定时查这个锁是否还在, 还在的话就延期



### 缓存的热点 Key 怎么处理?

#### 什么是热点 KEY

1. 单一 key 在突发事件中访问量突增, 会对单一的 Server 造成很很大压力, 超过 Server 极限时, 就导致了热点 Key 问题的产生

#### 怎么解决

1. 服务端 缓存: 即将数据缓存至服务端的内存中
   - 如何保证 Redis 和 服务端热点 Key 的数据一致性: 使用 Redis 自带的消息通知机制
2. 备份热点 Key: 即将热点 Key + 随机数, 随机分配至 Redis 其它节点中, 这样访问热点 key 的时候就会分配压力到其它节点l
   - Redis 集群中包含 `16384` 个哈希槽, 集群使用公式 `CRC16(key) % 16384` 来定位 key 属于哪个槽, 那么只需要在 key 后加随机数
     来储存和访问即可平均分布到不同的机器上了 

##### 如何找到热点 Key

- 凭借经验, 进行预估
- 客户端收集: 在操作 Redis 前对数据进行统计
- 抓包进行评估: Redis 使用了 TCP 协议与客户端进行通信, 通信协议采用的是 RESP, 所以能进行拦截宝进行解析
- 在 proxy 层, 对每一个 redis 请求进行收集上报
- Redis 自带命令查询: Redis 4.0.4 版本提供了 `redis-cli -hotkeys` 就能找出热点 key 