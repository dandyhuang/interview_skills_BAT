### tcp和ip协议区别

IP 协议和 TCP 协议虽然都会对数据进行拆分，但是 IP 协议以数据包（Package）为单位组织数据，而 TCP 协议以数据段（Segment）为单位组织数据。

### netstat看tcp连接的时候有关注过time_wait和close_wait吗？

### https加密过程

1. 客户端请求服务器获取`证书公钥`
2. 客户端(SSL/TLS)解析证书（无效会弹出警告）
3. 生成随机值
4. 用`公钥加密`随机值生成**密钥**
5. 客户端将`秘钥`发送给服务器
6. 服务端用`私钥`解密`秘钥`得到随机值
7. `将信息和随机值混合在一起`进行对称加密
8. 将加密的内容发送给客户端
9. 客户端用`秘钥`解密信息

- 验证证书

1. 客户端获取到了站点证书，拿到了站点的公钥
2. 客户端找到其站点证书颁发者的信息
3. `站点证书的颁发者`验证`服务端站点`是否可信
4. 往上回溯，找到`根证书颁发者`
5. 通过`根证书颁发者`一步步验证`站点证书颁布者`是否可信

### http1.1和http2.0区别

HTTP/1.1 的持久连接和管道机制允许复用TCP连接，在一个TCP连接中，也可以同时发送多个请求，但是所有的数据通信都是按次序完成的，服务器只有处理完一个回应，才会处理下一个回应。比如客户端需要A、B两个资源，管道机制(pipelining)允许浏览器同时发出A请求和B请求，但服务器还是按照顺序，先回应A请求，完成后再回应B请求，这样如果前面的回应特别慢，后面就会有很多请求排队等着，这称为“队头阻塞（Head-of-line blocking）”

2.0之前解决队头阻塞问题:

- 使用多个域名 

- 引入雪碧图  
- 将小图内联

## **HTTP/2**

HTTP/2 是如何解决HTTP/1.1 性能瓶颈的？使用Stream ID 来标识当前数据流属于哪个资源请求。HTTP/2以Google发布的SPDY协议为基础，于2015年发布。它不叫HTTP/2.0，因为标准委员会不打算再发布子版本了，下一个新版本将是HTTP/3。HTTP/2协议只在HTTPS环境下才有效，升级到HTTP/2，必须先启用HTTPS。HTTP/2解决了HTTP/1.1的性能问题，主要特点如下：

1. 二进制分帧：HTTP/1.1的头信息是文本（ASCII编码），数据体可以是文本，也可以是二进制；HTTP/2 头信息和数据体都是二进制，统称为“帧”：头信息帧和数据帧；
2. 多路复用（双工通信）：多路复用很好地解决了浏览器限制同一个域名下请求数量的问题，同时也更容易实现全速传输。通过单一的 HTTP/2 连接发起多重的请求-响应消息，即在`一个连接`里，客户端和浏览器都可以同时发送多个请求和响应，而不用按照顺序一一对应，这样避免了“队头堵塞”。HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行地在同一个 TCP 连接上双向交换消息。
3. 数据流：因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的**编号**。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。数据流发送到一半的时候，客户端和服务器都可以发送信号（`RST_STREAM`帧），取消这个数据流。HTTP/1.1取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。
4. 首部压缩：HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息压缩后再发送（SPDY 使用的是通用的DEFLATE 算法，而 HTTP/2 则使用了专门为首部压缩而设计的 HPACK 算法）。；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。
5. 服务端推送：HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。

### HTTP/2 还会队头阻塞吗?

HTTP/2 也存在队头阻塞问题，比如丢包。

如果造成队头阻塞，问题可能比http1.1还严重，因为只有一个tcp连接，后续的传输都要等前面，http/1.1 多个tcp连接，阻塞一个，其他的还可以正常跑

**HTTP/2下还会拥塞吗?**

由于 TCP 连接减少而使网络拥塞状况得以改观;

慢启动时间减少，拥塞和丢包恢复速度更快。

### http3.0技术

虽然tcp采用了滑动窗口来提高传输速率，但是当网络超时等问题，还会使窗口消耗殆尽，这样TCP 在传输层依然存在队头阻塞问题。 
**QUIC 使用的Packet Number 单调递增的设计，可以让数据包不再像TCP 那样必须有序确认，QUIC 支持乱序确认，当数据包Packet N 丢失后，只要有新的已接收数据包确认，当前窗口就会继续向右滑动**。

**有了Stream Offset 字段信息，属于同一个Stream ID 的数据包也可以乱序传输了**（HTTP/2 中仅靠Stream ID 标识，要求同属于一个Stream ID 的数据帧必须有序传输）

总结：QUIC 通过单向递增的Packet Number，配合Stream ID 与 Offset 字段信息，可以支持非连续确认应答Ack而不影响数据包的正确组装，摆脱了TCP 必须按顺序确认应答Ack 的限制（也即不能出现非连续的空位），解决了TCP 因某个数据包重传而阻塞后续所有待发送数据包的问题（也即队头阻塞问题）。

### 对称与非对称加密算法的区别

对称加密：加密和解密使用相同的密钥进行加密。常见的加密算法有`AES`,`3DES`,`DES`,`RC5`,`RC6`等

非对称加密：非对称加密算法需要两个密钥，公开密钥和私有密钥。公钥对数据进行加密的时候，只能通过对应的私钥才能解密。常见的非对称加密算法有`RSA`,`Elgamal`,`DSA`,`D-H`,`ECC`

### 1.什么是 TCP 粘包

TCP粘包：指A端发送2次请求，期望B端分2次读取，实际B端一次性获取了2条数据，数据未根据期望正确分割的一种现象。

- 造成TCP粘包的原因：

  1. TCP默认使用Nagle算法发送请求 Nagle算法主要为了减少网络中包数量，Nagle算法主要逻辑：

     - 收集多个小分组，在一个确认到来时一起发送
     - 只有上一个分组得到确认，才会发送下一个分组

     Nagle算法造成了发送方可能会出现粘包问题

  2. TCP接收数据包到缓存的速度>应用程序从缓存中读取数据包的速度 TCP接收的数据包会先保存到缓存中，当TCP接收数据包到缓存的速度>应用程序从缓存中读取数据包的速度时，存在多个包被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。

#### 2. TCP半包：

- 造成TCP半包的原因：
  - 发送方每次写入数据 > 套接字（Socket）缓冲区大小
  - 发送的数据大于协议的 MTU (Maximum Transmission Unit，最大传输单元)，因此必须拆包

#### 3. 为什么TCP没有解决半包、粘包的问题

由于TCP是面向连接的传输协议，TCP传输的数据是以流的形式，而流数据是没有明确的开始结尾边界，所以TCP也没办法判断哪一段流属于一个消息。 而UDP是没有半包、粘包的问题，因为UPD是面向消息的，它有边界协议，可以根据消息的格式区分消息的开始和结尾。

UDP和TCP两个发送消息就好像一个用桶运水，一个用水管运水，用水管运水的你是没办法区分那部分的水是属于哪一桶的。

#### **应用层如何解决半包粘包的问题**

上面部分我们知道UDP是没有半包粘包的问题的，因为它有边界协议，消息是有格式的。所以我们应用层的解决方案也是在这一思路上展开，解决半包粘包的问题其实就是定义消息边界的问题。

#### **应用层定义消息边界的几种方式**

##### i. 定长消息(fix length)

发送端和接收端约定消息长度, 缺点: 消息很短时, 效率很低, 浪费带宽

每次发送固定缓冲区大小数据。客户端和服务器约定每次发送请求的大小。例如客户端发送 1024 个字节，服务器接受 1024 个字节。

这样虽然可以解决粘包的问题，但是如果发送的数据小于 1024 个字节，就会导致数据内存冗余和浪费；且如果发送请求大于 1024 字节，会出现半包的问题，也就是数据接收的不完整。

##### ii. 特殊标志作为结束标志(delimiter based)

ftp协议就是这种方式, 缺点: 消息内容不能含有这种特殊标志, 会提前终止消息

##### iii. 定长包头中包含请求长度(length field based frame decoder)

每次都要尽可能的去读数据, 读到之后分析:

先取包头, 在包头里分析出包体的长度, 如果包头都不够, 要继续读数据拼接在已有的数据后面, 继续分析包体的长度, 拿到包体的长度就从包头结束的位置截取包体, 依次读取, 直到对方关闭

### TCP连接中出现RST的情况

- [1 端口未打开](http://my.oschina.net/costaxu/blog/127394#OSC_h2_1)
- [2 请求超时](http://my.oschina.net/costaxu/blog/127394#OSC_h2_2)
- [3 提前关闭](http://my.oschina.net/costaxu/blog/127394#OSC_h2_3)
- [4 在一个已关闭的socket上收到数据](http://my.oschina.net/costaxu/blog/127394#OSC_h2_4)
- 5.用于拒绝一个非法连接

### reference

[为什么 HTTP1.1 不能实现多路复用](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/290)

一定要看http://blog.chinaunix.net/uid-27105712-id-5793734.html

[tcp/ip之三次握手](https://www.huaweicloud.com/articles/f05a25dad9650e6cc999dd3dda0e84ae.html)

