# GC

### 三种经典的GC算法：

引用计数（reference counting）、标记-清扫（mark & sweep）、节点复制（Copying Garbage Collection），分代收集（Generational Garbage Collection）

- 引用计数：类似c++中的share_ptr,但无法循环调用等问题
- 标记-清扫：全局 标记阶段表明所有的存活单元，清扫阶段将垃圾单元回收，需要stw
- 节点复制：需要一半的空间存活数据，之后在交换。
- 分代收集：分为新生代和老年代，新生代的区域的垃圾回收频率要明显高于老年代区域

### STW

 Go 1.14 以前，如果所有的goroutine长时间得不到停止，那么STW也将无休止的等待。

### 三色标记算法

三色标记算法是对标记阶段的改进，原理如下：

1. 起初所有对象都是白色。

2. 从根出发扫描所有可达对象，标记为灰色，放入待处理队列。

3. 从队列取出灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色。

4. 重复 3，直到灰色对象队列为空。此时白色对象即为垃圾，进行回收。

- 强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；

- 弱三色不变性 — 黑色对象可以引用白色对象，白色对象存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象

#### 屏障技术

读屏障：需要在读操作加入代码片段，对用户性能影响很大

写屏障：

- 插入写屏障,  当黑色对象指向白色对象时，将白色对象标记为灰色(满足了**强三色不变性**)
- 删除写屏障，被删除的对象，如果自身为灰色或者白色，那么被标记为灰色(满足了**弱三色不变式**原则，保护灰色对象到白色对象的可达路径不会断。)

***插入写屏障***

golang 的回收没有混合屏障之前，一直是插入写屏障，由于栈赋值没有 hook 的原因，所以栈中没有启用写屏障，所以有 STW。 golang 的解决方法是：只是需要在结束时启动STW来重新扫描栈。这个自然就会导致整个进程的赋值器卡顿，所以后面 golang 是引用混合写屏障解决这个问题。混合写屏障之后，就没有 STW。

***删除写屏障***

goalng没有这一步，golang 的内存写屏障是由插入写屏障到混合写屏障过渡的。简单介绍一下，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。

***缺点***：

- 插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；
- 删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。

#### 混合写屏障

1. 混合写屏障继承了插入写屏障的优点，起始无需 STW 打快照，直接并发扫描垃圾即可；
2. 混合写屏障继承了删除写屏障的优点，赋值器是黑色赋值器，GC期间，任何在栈上创建的新对象，均为黑色。扫描过一次就不需要扫描了，这样就消除了插入写屏障时期最后 STW 的重新扫描栈；
3. 混合写屏障扫描精度继承了删除写屏障，比插入写屏障更低，随着带来的是 GC 过程全程无 STW；
4. 混合写屏障扫描栈虽然没有 STW，但是扫描某一个具体的栈的时候，还是要停止这个 goroutine 赋值器的工作的哈（针对一个 goroutine 栈来说，是暂停扫的，要么全灰，要么全黑哈，原子状态切换）；

### Go1.8 三色标记+混合写屏障

基于插入写屏障和删除写屏障在结束时需要STW来重新扫描栈，所带来的性能瓶颈，Go在1.8引入了混合写屏障的方式实现了弱三色不变式的设计方式，混合写屏障分下面四步

1. GC开始时将栈上可达对象全部标记为黑色（不需要二次扫描，无需STW）
2. GC期间，任何栈上创建的新对象均为黑色
3. 被删除引用的对象标记为灰色
4. 被添加引用的对象标记为灰色

### GC触发时机

**主动触发**：调用 runtime.GC 

**被动触发**：

- 使用系统监控，该触发条件由`runtime.forcegcperiod`变量控制，默认为 2 分钟。当超过两分钟没有产生任何 GC 时，强制触发 GC。
- 使用步调（Pacing）算法，其核心思想是控制内存增长的比例。如Go 的 GC 是一种比例 GC, 下一次 GC 结束时的堆大小和上一次 GC `存活`堆大小成比例. 由 GOGC 控制, 默认 100, 即 2 倍的关系, 200 就是 3 倍, 
  当Go新创建的对象所占用的内存大小，除以上次GC结束后**保留下来的对象**占用内存大小

### Go 语言中 GC 的流程是什么？

当前版本的 Go 以 STW 为界限，可以将 GC 划分为五个阶段：

阶段说明赋值器状态GCMark标记准备阶段，为并发标记做准备工作，启动写屏障STWGCMark扫描标记阶段，与赋值器并发执行，写屏障开启并发GCMarkTermination标记终止阶段，保证一个周期内标记任务完成，停止写屏障STWGCoff内存清扫阶段，将需要回收的内存归还到堆中，写屏障关闭并发GCoff内存归还阶段，将过多的内存归还给操作系统，写屏障关闭并发

### GC如何调优

通过go tool pprof 和 go tool trace等工具

1. 控制内存分配的速度，限制 goroutine 的数量，从而提高赋值器对 CPU 的利用率。

2. 减少并复用内存，例如使用 sync.Pool 来复用需要频繁创建临时对象，例如提前分配足够的内存来降低多余的拷贝。

3. 需要时，增大 GOGC 的值，降低 GC 的运行频率。

   

gc栈扫描

8.是否了解其他gc机制

内存管理方式

介绍一下大对象和小对象，为什么小对象多了会造成gc压力？

### References

[几行代码为老板省百万-某高并发服务GOGC及UDP Pool优化](https://mp.weixin.qq.com/s/EuJ3Pw0s24Nr1h2edn5Sgg)

[gc的认识]()

[Go GC 20 问](https://zhuanlan.zhihu.com/p/109431787)

​	
