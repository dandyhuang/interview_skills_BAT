# map

map中主要的数据结构有两种：哈希表和搜索树

Go语言中map采用的是哈希查找表，由一个key通过哈希函数得到哈希值，64位系统中就生成一个64bit的哈希值，由这个哈希值将key对应到不同的桶（bucket）中，当有多个哈希映射到相同的的桶中时，使用链表解决哈希冲突



### 查找
key经过hash后共64位，根据hmap中B的值，计算它到底要落在哪个桶时，桶的数量为2^B，如B=5，那么用64位最后5位表示第几号桶，在用hash值的高8位确定在bucket中的存储位置，当前bmap中的bucket未找到，则查询对应的overflow bucket，对应位置有数据则对比完整的哈希值，确定是否是要查找的数据。如果两个不同的key落在的同一个桶上，hash冲突使用链表法接近，遍
历	bucket中的key 如果当前处于map进行了扩容，处于数据搬移状态，则优先从oldbuckets查找

### 扩容
装载因子：count/2^B
触发条件：
1. 装填因子是否大于6.5
2. overflow bucket是否太多

解决方法：
1. 双倍扩容：扩容采取了一种称为“渐进式”地方式，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 bucket
2. 等量扩容：重新排列，极端情况下，重新排列也解决不了，map成了链表，性能大大降低，此时哈希种子hash0的设置，可以降低此类极端场景的发生。

### map无序
Go设计者为了让大家不依赖遍历的顺序，故意在实现map遍历时加入了随机数。因为map中如果扩容，key的迁移就会导致无序了。

### sync.Map

### 总结

解决并发读写 map 的思路是加一把大锁，或者把一个 map 分成若干个小 map，对 key 进行哈希，只操作相应的小 map。前者锁的粒度比较大，影响效率；后者实现起来比较复杂，容易出错。



### reference

[Concurrent_map多个map](https://github.com/orcaman/concurrent-map)